* 剪切和存储文本
* Menu:
  当你用'kill命令剪切或删除掉缓存（buffer）中的一段文本内容时。这段内容将会被保存在list中，你可以使用'yank命令召回他。
** Storing Text
   emacs用一个list来管理被存储的文本串。通过使用'car和'nthcdr函数，我们就可以检索list中的文本串。
  eg:
  (car (nthcdr 1 '("another piece"
                      "a piece of text"
                      "previous piece")))
          => "a piece of text"
  这个list被称为”kill ring“，本章主要就是讲解这个kill ring的用法的。
** zap-to-char
*** Complete zap-to-char
    'zap-to-char函数的功能是删除从指定光标位置起到指定字符（可以通过传递数字参数来确定是指定字符的第几个）处之间的文本内容。
    被删除后的文本将会被放在kill ring中去。我们可以通过输入'C-y('yank)来召回被删除的文本内容.
    如果被指定的字符并不存在，'zap-to-char将会给我们"Search failed"的提示。
    下面是函数的完整实现:
    (defun zap-to-char (arg char)
       "Kill up to and including ARG'th occurrence of CHAR.
     Case is ignored if `case-fold-search' is non-nil in the current buffer.
     Goes backward if ARG is negative; error if CHAR not found."
       (interactive "p\ncZap to char: ")
       (if (char-table-p translation-table-for-input)
           (setq char (or (aref translation-table-for-input char) char)))
       (kill-region (point) (progn
                              (search-forward (char-to-string char)
                                              nil nil arg)
                              (point))))
*** zap-to-char-interactive
       p代表一个前缀数值参数，c代表一个字符操作。
       如果'zap-to-char是在一个只读buffer中使用，那么该函数只能将文本复制到kill ring，而不能删除它。
       echo 区域讲会给出该buffer仅只读的提示。
*** zap-to-char body
    'char-table-p 判断检查输入的参数是否在参数表中，如果存在的话，将会把char 赋值为char参数表中的一个字符值。
    'aref 从数组列表中提取值。
    'progn
    'search-forward
*** search-forward
    'char-to-string将字符作为字符串看待。下面我们来看'search-forward这个函数
    第一个参数必须是一个字符串，它是我们搜索的目标。
    第二个参数是设定字符串搜索的界限，这里为nil代表搜索界限为整个buffer。
    第三个参数告诉函数如果搜索失败的话，将会怎么做。nil将会使函数发出一个错误信号来告诉emacs。
    第四个参数告诉函数要搜寻的字符串重复的次数，该参数为可选参数。如果该参数不存在的话，则默认值为1，如果参数默认值为负的话。搜索将会往前搜索。
    ’search-forward函数的摸板如下所示：
     (search-forward "TARGET-STRING"
                     LIMIT-OF-SEARCH
                     WHAT-TO-DO-IF-SEARCH-FAILS
                     REPEAT-COUNT)
*** progn
    'progn使它的每一个参数表达式按顺序执行，并将最后一个表达式的返回值返回。
    'progn的模板如下所示。
    (progn
    BODY...)
*** Summing up zap-to-char
** kill-region
   'zap-to-char函数使用到了'kill-region函数，该函数从一段区域中剪切文本，并将这段文本保存在 kill ring中。
   我们则可以通过它来还原我们删除掉的文本。
   'kill-region将会使用'condition-case和'copy-region-as-kill函数这两个我们都会在下面详加解释
*** Complete kill-region
               完整的函数定义如下所示:
	       (defun kill-region (beg end)
	       "Kill (\"cut\") text between point and mark.
	       This deletes the text from the buffer and saves it in the kill ring.
	       The command \\[yank] can retrieve it from there. ... "

	       ;; * Since order matters, pass point first.
	       (interactive (list (point) (mark)))
	       ;; * And tell us if we cannot cut the text.
	       ;; `unless' is an `if' without a then-part.
	       (unless (and beg end)
               (error "The mark is not set now, so there is no region"))
	       
	       ;; * `condition-case' takes three arguments.
	       ;;    If the first argument is nil, as it is here,
	       ;;    information about the error signal is not
	       ;;    stored for use by another function.
	       (condition-case nil

               ;; * The second argument to `condition-case' tells the
               ;;    Lisp interpreter what to do when all goes well.

               ;;    It starts with a `let' function that extracts the string
               ;;    and tests whether it exists.  If so (that is what the
               ;;    `when' checks), it calls an `if' function that determines
               ;;    whether the previous command was another call to
               ;;    `kill-region'; if it was, then the new text is appended to
               ;;    the previous text; if not, then a different function,
               ;;    `kill-new', is called.

               ;;    The `kill-append' function concatenates the new string and
               ;;    the old.  The `kill-new' function inserts text into a new
               ;;    item in the kill ring.

               ;;    `when' is an `if' without an else-part.  The second `when'
               ;;    again checks whether the current string exists; in
               ;;    addition, it checks whether the previous command was
               ;;    another call to `kill-region'.  If one or the other
               ;;    condition is true, then it sets the current command to
               ;;    be `kill-region'.
               (let ((string (filter-buffer-substring beg end t)))
               (when string                    ;STRING is nil if BEG = END
               ;; Add that string to the kill ring, one way or another.
               (if (eq last-command 'kill-region)
               ;;    - `yank-handler' is an optional argument to
                   ;;    `kill-region' that tells the `kill-append' and
                   ;;    `kill-new' functions how deal with properties
                   ;;    added to the text, such as `bold' or `italics'.
                   (kill-append string (< end beg) yank-handler)
                   (kill-new string nil yank-handler)))
		   (when (or string (eq last-command 'kill-region))
		   (setq this-command 'kill-region))
		   nil)
		   
		   ;;  * The third argument to `condition-case' tells the interpreter
		   ;;    what to do with an error.
		   ;;    The third argument has a conditions part and a body part.
		   ;;    If the conditions are met (in this case,
		   ;;             if text or buffer are read-only)
		   ;;    then the body is executed.
		   ;;    The first part of the third argument is the following:
		   ((buffer-read-only text-read-only) ;; the if-part
		   ;; ...  the then-part
		   (copy-region-as-kill beg end)
		   ;;    Next, also as part of the then-part, set this-command, so
		   ;;    it will be set in an error
		   (setq this-command 'kill-region)
		   ;;    Finally, in the then-part, send a message if you may copy
		   ;;    the text to the kill ring without signaling an error, but
		   ;;    don't if you may not.
		   (if kill-read-only-ok
		   (progn (message "Read only text copied to kill ring") nil)
		   (barf-if-buffer-read-only)
		   ;; If the buffer isn't read-only, the text is.
		   (signal 'text-read-only (list (current-buffer)))))))
*** condition-case
                (condition-case
		VAR
		BODYFORM
		ERROR-HANDLER...)
		condition-case可以支持错误处理。
		第三部分错误处理部分不太理解，暂时搁置。
*** Lisp macro
              上面的'kill-region函数中的'when表达式是一个Lisp宏。它相当于一种没有else的if结构。Lisp宏能够使你定义一种新的结构和一些其他语言特性。
	      'unless表达式也是一个宏，它和when相反，是一个没有then 的if结构。
	      
** copy-region-as-kill
                当你调用'copy-region-as-kill函数时是在调用'kill-region之后，emacs将会追加之前复制的文本到之后复制的文本之后。
		这意味着如果你用'yank命令召回之前的文本时，你将会把两个函数删除掉的文本内容一起召回。而且在一些特殊情况下一些其他命令如果在'copy-region-as-kill之前
		使用的话，该函数将会复制文本已一种独特的形式存储到kill  ring 中去。
*** Complete copy-region-as-kill
                函数定义实现如下:
		(defun copy-region-as-kill (beg end)
		"Save the region as if killed, but don't kill it.
		In Transient Mark mode, deactivate the mark.
		If `interprogram-cut-function' is non-nil, also save the text for a window
		system cut and paste."
		(interactive "r")
		(if (eq last-command 'kill-region)
		(kill-append (filter-buffer-substring beg end) (< end beg))
		(kill-new (filter-buffer-substring beg end)))
		(if transient-mark-mode
		(setq deactivate-mark t))
		nil)
		* 
		  (if transient-mark-mode
		(setq deactivate-mark t))
		这两行代码的意思是如果Transient Mark mode被开启的话，那么就阻止该复制区域被高亮显示。
*** copy-region-as-kill body
**** last-command & this-command
**** kill-append function
**** kill-new function
** Digression into c
** defvar
*** See variable current value
*** defvar and asterisk
** cons & search-fwd Review
** search Exercises
