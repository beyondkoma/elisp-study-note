* 剪切和存储文本
* Menu:
  当你用'kill命令剪切或删除掉缓存（buffer）中的一段文本内容时。这段内容将会被保存在list中，你可以使用'yank命令召回他。
** Storing Text
   emacs用一个list来管理被存储的文本串。通过使用'car和'nthcdr函数，我们就可以检索list中的文本串。
  eg:
  (car (nthcdr 1 '("another piece"
                      "a piece of text"
                      "previous piece")))
          => "a piece of text"
  这个list被称为”kill ring“，本章主要就是讲解这个kill ring的用法的。
** zap-to-char
*** Complete zap-to-char
    'zap-to-char函数的功能是删除从指定光标位置起到指定字符（可以通过传递数字参数来确定是指定字符的第几个）处之间的文本内容。
    被删除后的文本将会被放在kill ring中去。我们可以通过输入'C-y('yank)来召回被删除的文本内容.
    如果被指定的字符并不存在，'zap-to-char将会给我们"Search failed"的提示。
    下面是函数的完整实现:
    (defun zap-to-char (arg char)
       "Kill up to and including ARG'th occurrence of CHAR.
     Case is ignored if `case-fold-search' is non-nil in the current buffer.
     Goes backward if ARG is negative; error if CHAR not found."
       (interactive "p\ncZap to char: ")
       (if (char-table-p translation-table-for-input)
           (setq char (or (aref translation-table-for-input char) char)))
       (kill-region (point) (progn
                              (search-forward (char-to-string char)
                                              nil nil arg)
                              (point))))
*** zap-to-char-interactive
       p代表一个前缀数值参数，c代表一个字符操作。
       如果'zap-to-char是在一个只读buffer中使用，那么该函数只能将文本复制到kill ring，而不能删除它。
       echo 区域讲会给出该buffer仅只读的提示。
*** zap-to-char body
    'char-table-p 判断检查输入的参数是否在参数表中，如果存在的话，将会把char 赋值为char参数表中的一个字符值。
    'aref 从数组列表中提取值。
    'progn
    'search-forward
*** search-forward
    'char-to-string将字符作为字符串看待。下面我们来看'search-forward这个函数
    第一个参数必须是一个字符串，它是我们搜索的目标。
    第二个参数是设定字符串搜索的界限，这里为nil代表搜索界限为整个buffer。
    第三个参数告诉函数如果搜索失败的话，将会怎么做。nil将会使函数发出一个错误信号来告诉emacs。
    第四个参数告诉函数要搜寻的字符串重复的次数，该参数为可选参数。如果该参数不存在的话，则默认值为1，如果参数默认值为负的话。搜索将会往前搜索。
    ’search-forward函数的摸板如下所示：
     (search-forward "TARGET-STRING"
                     LIMIT-OF-SEARCH
                     WHAT-TO-DO-IF-SEARCH-FAILS
                     REPEAT-COUNT)
*** progn
    'progn使它的每一个参数表达式按顺序执行，并将最后一个表达式的返回值返回。
    'progn的模板如下所示。
    (progn
    BODY...)
*** Summing up zap-to-char
** kill-region
   'zap-to-char函数使用到了'kill-region函数，该函数从一段区域中剪切文本，并将这段文本保存在 kill ring中。
   我们则可以通过它来还原我们删除掉的文本。
   'kill-region将会使用'condition-case和'copy-region-as-kill函数这两个我们都会在下面详加解释
*** Complete kill-region
*** condition-case
*** Lisp macro
** copy-region-as-kill
*** Complete copy-region-as-kill
*** copy-region-as-kill body
** Digression into c
** defvar
*** See variable current value
*** defvar and asterisk
** cons & search-fwd Review
** search Exercises
