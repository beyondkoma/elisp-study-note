#+TITLE: templatecdr程序讲解
#+AUTHOR: gaolan
#+STARTUP: indent
#+EMAIL:850239158@qq.com

* main入口函数
** runPara 对象
   /该变量将把配置文件的信息，全部读取出来./


   该类类型CRuntimePara的主要数据结构为：

#+BEGIN_CENTER
   * private:
       std::map<std::string,std::string> _mapParaValue;
     该结构将存储每一个具体字段的信息。
   * std::map<std::string,CRuntimePara> _mapChild;
     该结构将存储子结构的信息。
#+END_CENTER
** Service* svc = svcFactory->getService(runPara.getString("SVCTYPE","CONTAINERSERVICE"),runPara)
      /该 svcFactory指针（CServiceFactory *） 将根据配置文件中"SVCTYPE"指向的值来生成对应的服务对象svc（多态对象).
   主要有四大服务： "CONTAINERSERVICE"， "FILESTORESERVICE"，"SOCKETSERVICE"，"IMEISERVICE"。/
** Runable * run = CRunableFactory::instance()->getRunable(CRunableFactory::RUN_IN_PROCESS_ENV)
    /这里产生一个将生成一个Runable类型的指针对象，该对象用来管理新开启进程或者线程的运行，服务类型（四大服务）./
** run->setService(svc)
  /这里将加载上面生成的服务对象。我们这里开启的首个服务是"CONTAINERSERVICE"的./
** run->run()
    /在这里我们将fork出一个子进程出来，用来执行"CONTAINERSERVICE"服务。/
*** ContainerService::run()
    /在这里我们的子进程将开始工作/
**** startServer()
          std::map<std::string,CRuntimePara> _mapServiceConfig；
     该结构用来管理即将准备开启服务的所有项。

***** tryStartOneService((*iterSvcPara).second)
        该函数将用来开启子服务。
***** run = CRunableFactory::instance()->getRunable(CRunableFactory::RUN_IN_PROCESS_ENV) 
        可以根据配置文件选择开启子进程还是子线程。
***** run->setService(psvc)
***** run->run()
        这里我们先只看FileStoreService这个服务。
****** void FileStoreService::runService()
******* pTrans->Init(_RunPara)
	  这里我们将读取该子服务的配置文件，存储相应的数据，并初始化套接口的内容。
******** _vecParser
	    将配置文件中的解析信息，加载到_vecParser中,以备使用。
	 结构如下std::vector<templateParser*> _vecParser;
******** client_start（）
	 将网络通讯部分的信息初始化。
********* theMessagePool.start()
	  这里主要是将线程池打开（开启新的线程池）。它通过循环来管理XMessageQueue对象
	  控制每一个XMessageQueue 按顺序执行。
******** SetMDSSSParam(g_lpszMainDbUrl, (char*)g_lpszHostPortName.c_str())
********* g_hMainDb = client_open(pHostIp)
	   根据要访问的网络地址开启套接字。
********** pque = XMWFactory::BuildQueueConnection(clientUrl, "xczy", "xczy",true)
      	   这里我们将完成客户端套接口的初始化，包括套接口初始化参数设置，connect()等操作。
	   函数执行成功将返回新生成的XMessageQueue类型的对象。
	   XMessageQueue将维持XMWConnection这个连接的运行。
********** theMessagePool.RegisterQueue(pque)
	   把上面生成的XMessageQueue注册到theMessagePool中去，交由线程池来管理。

******* while 循环处理
******** bContinue = pTrans->getRecord()
	 总共有两种类型的数据，xml类型的我们先不考虑。
	 这里 pTrans是 File_translater类型的 对象，作为FileStoreService的私有成员变量。
********* ReadingFile != NULL。
	  说明文件流对象，正在运行中。
	  我们将用fgets将行数据读取到 _chRecord中去，并返回处理。
********* ReadingFile == NULL。
	  这里我们将做读取文件内容的工作，将文件指针存储到ReadingFile中去。并做一些必要的处理工作，比较繁琐和乱。
********** getFile（）
	   获取文件给ReadingFile赋值。
********** GetFileList()
	    
******** bContinue = pTrans->translateRecord()
********* (_vecParser[i])->DecodeRecord(_chRecord, _msg.message, _msg.length)
	  这里我们将对上面获取到的行数据进行解析，并将解析的结果存储到_vecMessage中去。
	  该结构定义如下std::vector<MESSAGE> _vecMessage；
	  解析的依据是根据配置文件中"PARMTEMPLATE1"字段对应的值进行解析。具体细节暂时没有分析。
******** bContinue = pTrans->sendRecordToDb()
	 把_vecMessage中的数据取出来，通过主通道向Db发送数据。
********* SendSSN2DB((*ite).message, (*ite).length)
********** client_enqueue(pstrDest, nLen, g_hMainDb)
	   这里我们将把数据pstrDest存储到XMessageQueue中去，并交由线程池来处理。

**** while循环
***** maintainService（）
           该函数主要做的是维持工作，我们用std::map<std::string,Runable*> _mapService;
      来记录正在运行的子服务。如果子服务不再运行而且"SVCUSED"=1，则我们将重新开启子服务
      tryStartOneService((*iteRunPara).second)
** while循环
  /主进程做循环维护工作，等待子进程的结束，返回必要的日志信息。/

   

